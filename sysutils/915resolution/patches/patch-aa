$NetBSD: patch-aa,v 1.3 2008/08/25 15:11:47 joerg Exp $

--- 915resolution.c.orig	Sun Apr 15 10:46:56 2007
+++ 915resolution.c
@@ -22,12 +22,58 @@
 #include <string.h>
 #include <sys/mman.h>
 #include <fcntl.h>
+#ifdef __linux__
 #include <sys/io.h>
+#endif
+#ifdef __NetBSD__
+#include <machine/pio.h>
+#include <machine/sysarch.h>
+# if defined(__i386__)
+#define iopl(a) i386_iopl(a)
+# elif defined(__x86_64__)
+#define iopl(a) x86_64_iopl(a)
+# endif
+#endif
 #include <unistd.h>
 #include <assert.h>
 
+static uint8_t
+asm_inb(unsigned port)
+{
+	uint8_t data;
+	__asm volatile("inb %w1,%0" : "=a" (data) : "d" (port));
+	return data;
+}
 
+static __inline void
+asm_outb(uint8_t data, unsigned port)
+{
+	__asm volatile("outb %0,%w1" : : "a" (data), "d" (port));
+}
 
+static uint32_t
+asm_inl(unsigned port)
+{
+	uint32_t data;
+	__asm volatile("inl %w1,%0" : "=a" (data) : "d" (port));
+	return data;
+}
+
+static __inline void
+asm_outl(uint32_t data, unsigned port)
+{
+	__asm volatile("outl %0,%w1" : : "a" (data), "d" (port));
+}
+
+#undef	inb
+#undef	outb
+#define	inb asm_inb
+#define	outb asm_outb
+#undef	inl
+#undef	outl
+#define	inl asm_inl
+#define	outl asm_outl
+
 #define NEW(a) ((a *)(calloc(1, sizeof(a))))
 #define FREE(a) (free(a))
 
@@ -165,7 +211,16 @@ typedef struct {
 void initialize_system(char * filename) {
 
     if (!filename) {
+#if !defined(__FreeBSD__) & !defined(__DragonFly__) & !defined(__minix)
         if (iopl(3) < 0) {
+#else
+#  if defined(__minix)
+        FILE *iof = fopen("/dev/mem", "rw");
+#  else /* FreeBSD or DrogonFly */
+        FILE *iof = fopen("/dev/io", "r");
+#  endif 
+        if(iof == NULL) {
+#endif
             perror("Unable to obtain the proper IO permissions");
             exit(2);
         }
@@ -213,6 +268,10 @@ chipset_type get_chipset(cardinal id) {
         type = CT_945GM;
         break;
 
+    case 0x27ac8086:
+        type = CT_945GM;
+        break;
+
     case 0x29708086:
         type = CT_946GZ;
         break;
@@ -313,9 +372,17 @@ vbios_map * open_vbios(char * filename, chipset_type f
             exit(2);
         }
         
+#ifndef __minix        
         map->bios_ptr = mmap(0, VBIOS_SIZE,
                              PROT_READ | PROT_WRITE, MAP_SHARED,
                              map->bios_fd, VBIOS_START);
+#else        
+        {
+            void * ptr = malloc(VBIOS_SIZE);
+            pread(map->bios_fd, ptr, VBIOS_SIZE, VBIOS_START);
+            map->bios_ptr = ptr;
+        }
+#endif
         
         if (map->bios_ptr == MAP_FAILED) {
             if (map->chipset == CT_UNKWN) {
@@ -336,9 +403,17 @@ vbios_map * open_vbios(char * filename, chipset_type f
             exit(2);
         }
         
+#ifndef __minix        
         map->bios_ptr = mmap(0, VBIOS_SIZE,
                              PROT_READ | PROT_WRITE, MAP_SHARED,
                              map->bios_fd, 0);
+#else        
+        {
+            void * ptr = malloc(VBIOS_SIZE);
+            pread(map->bios_fd, ptr, VBIOS_SIZE, 0);
+            map->bios_ptr = ptr;
+        }
+#endif
         
         if (map->bios_ptr == MAP_FAILED) {
             if (map->chipset == CT_UNKWN) {
@@ -479,7 +554,11 @@ void close_vbios(vbios_map * map) {
         exit(2);
     }
 
+#ifndef __minix 
     munmap(map->bios_ptr, VBIOS_SIZE);
+#else /* __minix */
+    free(map->bios_ptr);
+#endif
     close(map->bios_fd);
 
     FREE(map);
@@ -739,6 +818,12 @@ void set_mode(vbios_map * map, cardinal mode, cardinal
             }
         }
     }
+#ifdef __minix
+    /* write out change to file */
+    /* FIXME: This may not work when filename was given */
+    lseek(map->bios_fd, VBIOS_START, SEEK_SET);
+    write(map->bios_fd, map->bios_ptr, VBIOS_SIZE);
+#endif
 }   
 
 void display_map_info(vbios_map * map) {
